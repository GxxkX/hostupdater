#!/bin/sh

# Host Updater Script
# 管理多个hosts订阅源，支持定时抓取和手动抓取
# Copyright (c) 2025 Gxxkx

CONFIG_FILE="/etc/config/hostupdater"
SOURCES_FILE="/etc/hostupdater/sources.conf"
HOSTS_FILE="/etc/hosts"
BACKUP_DIR="/etc/hostupdater/backup"
TEMP_DIR="/tmp/hostupdater"
LOG_FILE="/var/log/hostupdater.log"

# 日志函数
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "$LOG_FILE"
}

# 错误处理
error_exit() {
    log "错误: $1"
    exit 1
}

# 创建必要的目录
create_dirs() {
    mkdir -p "$BACKUP_DIR" "$TEMP_DIR"
}

# 备份当前hosts文件
backup_hosts() {
    if [ ! -f "$BACKUP_DIR/hosts.original" ]; then
        cp "$HOSTS_FILE" "$BACKUP_DIR/hosts.original"
        log "已备份原始hosts文件"
    fi
    cp "$HOSTS_FILE" "$BACKUP_DIR/hosts.$(date +%Y%m%d_%H%M%S)"
    log "已备份当前hosts文件"
}

# 下载hosts文件
download_hosts() {
    local url="$1"
    local name="$2"
    local temp_file="$TEMP_DIR/${name}.tmp"
    
    log "正在下载: $name ($url)"
    
    if curl -s -L -o "$temp_file" "$url" --connect-timeout 30 --max-time 300; then
        # 统一换行符，去除CRLF
        sed -i 's/\r$//' "$temp_file" 2>/dev/null
        if [ -s "$temp_file" ]; then
            log "下载成功: $name ($(wc -l < "$temp_file" | tr -d ' ' ) 行)"
            return 0
        else
            log "下载失败: $name (文件为空)"
            return 1
        fi
    else
        log "下载失败: $name (网络错误)"
        return 1
    fi
}

# 解析hosts文件内容（支持IPv4与IPv6）
# 解析到临时文件后打印出来
parse_hosts() {
    local file="$1"
    local name="$2"
    local out="$TEMP_DIR/${name}.parsed"
    local count=0
    : > "$out"
    log "正在解析: $name"
    
    while IFS= read -r line; do
        case "$line" in
            \#*|"") continue ;;
        esac
        # 支持IPv4或IPv6记录（至少一个主机名）
        echo "$line" | grep -qE '^((([0-9]{1,3}\.){3}[0-9]{1,3})|([0-9A-Fa-f:]+))[[:space:]]+[^[:space:]]+' || continue
        printf "%s\n" "$line" >> "$out"
        count=$((count+1))
    done < "$file"
    
    log "解析完成: $name (有效行 $count)"
    cat "$out"
}

# 对合并结果进行去重：按出现顺序保留第一个域名映射，后续重复域名跳过；原hosts优先（因为最先写入）
dedupe_merged() {
    local in_file="$1"
    local out_file="$2"
    awk '
    BEGIN{ OFS="\t" }
    /^#/ { print; next }
    /^\s*$/ { print; next }
    {
        # 分割为IP + 主机名列表
        ip=$1; n=split($0, f, /[\t ]+/); if (n<2){ next }
        kept=""; cnt=0;
        for(i=2;i<=n;i++){
            h=f[i]; if(h=="") continue;
            if(!(h in seen)){
                seen[h]=1; cnt++; if(kept=="") kept=h; else kept=kept"\t"h;
            }
        }
        if(cnt>0){ print ip, kept }
    }
    ' "$in_file" > "$out_file"
}

# 合并所有hosts文件
merge_hosts() {
    local out="$TEMP_DIR/merged.out"
    : > "$out"
    printf "# Generated by Host Updater on %s\n" "$(date '+%Y-%m-%d %H:%M:%S')" >> "$out"
    printf "# Original hosts file backup: %s\n\n" "$BACKUP_DIR/hosts.original" >> "$out"
    
    # 添加原始hosts文件中的所有有效条目（保留IPv4/IPv6，包括ff02组播等）
    if [ -f "$BACKUP_DIR/hosts.original" ]; then
        printf "# BEGIN ORIGINAL HOSTS\n" >> "$out"
        while IFS= read -r line; do
            case "$line" in
                \#*|"") continue ;;
            esac
            printf "%s\n" "$line" >> "$out"
        done < "$BACKUP_DIR/hosts.original"
        printf "# END ORIGINAL HOSTS\n\n" >> "$out"
    fi
    
    # 添加下载的hosts条目，按源包裹BEGIN/END注释
    local files_found=0
    for file in "$TEMP_DIR"/*.tmp; do
        [ -f "$file" ] || continue
        files_found=$((files_found+1))
        local name
        name=$(basename "$file" .tmp)
        local content
        content=$(parse_hosts "$file" "$name")
        if [ -n "$content" ]; then
            printf "# BEGIN SOURCE: %s\n" "$name" >> "$out"
            printf "%s\n" "$content" >> "$out"
            printf "# END SOURCE: %s\n\n" "$name" >> "$out"
        else
            log "源 $name 未解析出有效行，跳过写入"
        fi
    done
    log "待合并源文件: $files_found 个"
    
    # 去重：保留最先出现（原hosts优先）
    local deout="$TEMP_DIR/merged.dedup"
    dedupe_merged "$out" "$deout"
    cat "$deout"
}

# 更新hosts文件
update_hosts() {
    local new_content="$1"
    printf "%s" "$new_content" > "$HOSTS_FILE"
    if [ $? -eq 0 ]; then
        log "hosts文件更新成功"
        return 0
    else
        log "hosts文件更新失败"
        return 1
    fi
}

# 清理临时文件
cleanup() {
    rm -rf "$TEMP_DIR"/* 2>/dev/null
    log "已清理临时文件"
}

# 从配置文件读取源列表
get_sources() {
    if [ -f "$SOURCES_FILE" ]; then
        cat "$SOURCES_FILE" | grep -v '^#' | grep -v '^$' | while IFS='|' read -r name url enabled; do
            if [ "$enabled" = "1" ]; then
                echo "$name|$url"
            fi
        done
    fi
}

# 获取某个源的URL
get_source_url_by_name() {
    local target="$1"
    if [ -f "$SOURCES_FILE" ]; then
        while IFS='|' read -r name url enabled; do
            [ -z "$name" ] && continue
            echo "$name" | grep -q '^#' && continue
            if [ "$name" = "$target" ]; then
                echo "$url|$enabled"
                return 0
            fi
        done < "$SOURCES_FILE"
    fi
    return 1
}

# 主更新函数
do_update() {
    log "开始更新hosts文件..."
    
    create_dirs
    backup_hosts
    cleanup
    
    local download_success=false
    local sources
    sources=$(get_sources)
    
    if [ -z "$sources" ]; then
        log "没有找到启用的hosts源"
        return 1
    fi
    
    # 避免管道子shell造成变量不可见，使用 here-string 在当前shell中读取
    while IFS='|' read -r name url; do
        [ -z "$name" ] && continue
        if download_hosts "$url" "$name"; then
            download_success=true
        fi
    done <<EOF
$sources
EOF
    
    if [ "$download_success" = true ]; then
        local merged_content
        merged_content=$(merge_hosts)
        if [ -n "$merged_content" ]; then
            if update_hosts "$merged_content"; then
                log "hosts更新完成"
                cleanup
                return 0
            else
                log "hosts更新失败"
                cleanup
                return 1
            fi
        else
            log "合并结果为空，保持原状"
            return 1
        fi
    else
        log "所有下载都失败了"
        cleanup
        return 1
    fi
}

# 显示状态
show_status() {
    echo "Host Updater 状态:"
    echo "配置文件: $CONFIG_FILE"
    echo "源文件: $SOURCES_FILE"
    echo "hosts文件: $HOSTS_FILE"
    echo "备份目录: $BACKUP_DIR"
    echo "日志文件: $LOG_FILE"
    echo ""
    
    if [ -f "$SOURCES_FILE" ]; then
        echo "已配置的源:"
        cat "$SOURCES_FILE" | grep -v '^#' | grep -v '^$' | while IFS='|' read -r name url enabled; do
            local status="禁用"
            if [ "$enabled" = "1" ]; then
                status="启用"
            fi
            echo "  $name: $status"
        done
    else
        echo "未找到源配置文件"
    fi
}

# 显示帮助信息
show_help() {
    echo "Host Updater - 管理多个hosts订阅源"
    echo ""
    echo "用法: $0 [命令] [可选参数]"
    echo ""
    echo "命令:"
    echo "  update                  执行全部更新"
    echo "  update-source <name>    只更新指定订阅源"
    echo "  status                  显示状态"
    echo "  backup                  创建备份"
    echo "  restore                 还原到原始状态"
    echo "  help                    显示此帮助信息"
    echo ""
    echo "示例:"
    echo "  $0 update                # 更新全部"
    echo "  $0 update-source adguard # 只更新adguard源"
}

# 还原到原始状态
do_restore() {
    if [ -f "$BACKUP_DIR/hosts.original" ]; then
        cp "$BACKUP_DIR/hosts.original" "$HOSTS_FILE"
        log "已还原到原始hosts文件"
        echo "已还原到原始hosts文件"
    else
        log "未找到原始hosts备份文件"
        echo "错误: 未找到原始hosts备份文件"
        return 1
    fi
}

# 主程序
case "$1" in
    update)
        do_update
        ;;
    update-source)
        if [ -z "$2" ]; then
            echo "错误: 请输入订阅源名称"
            exit 1
        fi
        name="$2"
        info=$(get_source_url_by_name "$name") || { echo "错误: 未找到该订阅源"; exit 1; }
        url="${info%%|*}"
        enabled="${info##*|}"
        if [ "$enabled" != "1" ]; then
            echo "警告: 该订阅源未启用，仍尝试抓取"
        fi
        create_dirs
        backup_hosts
        cleanup
        if download_hosts "$url" "$name"; then
            merged=$(merge_hosts)
            update_hosts "$merged"
            cleanup
            echo "已完成单源更新: $name"
            exit 0
        else
            cleanup
            echo "单源更新失败: $name"
            exit 1
        fi
        ;;
    status)
        show_status
        ;;
    backup)
        create_dirs
        backup_hosts
        ;;
    restore)
        do_restore
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        show_help
        exit 1
        ;;
esac 